/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package team.cagayakegirls.cake;

import com.electronwill.nightconfig.core.UnmodifiableCommentedConfig;
import com.electronwill.nightconfig.core.io.ConfigWriter;
import com.electronwill.nightconfig.toml.TomlFormat;
import com.google.gson.*;
import com.google.gson.stream.JsonWriter;
import org.gradle.api.plugins.PluginAware;
import team.cagayakegirls.cake.api.MixinEnvironment;
import net.fabricmc.loom.LoomGradleExtension;
import net.fabricmc.loom.util.ModPlatform;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.Task;
import org.gradle.api.file.FileCollection;
import org.gradle.api.plugins.JavaPlugin;
import org.gradle.api.plugins.JavaPluginExtension;
import org.gradle.api.tasks.SourceSet;
import org.gradle.api.tasks.compile.JavaCompile;
import team.cagayakegirls.cake.extension.ForgifiedFabricApiExtension;
import team.cagayakegirls.cake.extension.IncludedJarsExtension;
import team.cagayakegirls.cake.extension.MappingsExtension;
import team.cagayakegirls.cake.extension.ModDependencyExtension;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.*;

public class CakeGradlePlugin implements Plugin<Project> {
    private CakeExtension cakeExtension;

    @Override
    public void apply(Project project) {
        cakeExtension = project.getExtensions().create("cake", CakeExtension.class, project);

        project.afterEvaluate(this::afterEvaluate);

        project.getDependencies().getExtensions().create("includedJars", IncludedJarsExtension.class, project, cakeExtension);

        project.getExtensions().create("forgifiedFabricApi", ForgifiedFabricApiExtension.class);
        project.getExtensions().create("modDeps", ModDependencyExtension.class);
        project.getExtensions().create("cakeMappings", MappingsExtension.class);
    }

    private void afterEvaluate(Project project) {
        FileCollection thisJar = project.files(getClass().getProtectionDomain().getCodeSource().getLocation());
        LoomGradleExtension loomExtension = LoomGradleExtension.get(project);

        loomExtension.getPlatform();

        if (cakeExtension.getEnableAnnotationProcessor().get()) {
            try (InputStream is = getClass().getClassLoader().getResourceAsStream("META-INF/jars/api.jar")) {
                File file = new File(project.getProjectDir(), ".gradle/cake");
                file.mkdirs();
                file = new File(file, "cakeGradlePlugin-api.jar");
                Files.copy(Objects.requireNonNull(is), file.toPath(), StandardCopyOption.REPLACE_EXISTING);
                project.getDependencies().add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME, project.files(file));
            } catch (Exception e) {
                project.getLogger().debug("Errored extracting cake api", e);
            }

            project.getDependencies().add(JavaPlugin.ANNOTATION_PROCESSOR_CONFIGURATION_NAME, thisJar);

            for (SourceSet sourceSet : project.getExtensions().getByType(JavaPluginExtension.class).getSourceSets())
                for (File resourcesDir : sourceSet.getResources().getSrcDirs()) {
                    File jsonFile = new File(resourcesDir, "fabric.mod.json");
                    if (!jsonFile.exists())
                        continue;

                    for (Task javaCompile : project.getTasksByName("compileJava", false))
                        cakeExtension.writeAPSettings((JavaCompile) javaCompile);
                }


            if (cakeExtension.getEnableEntrypoints().get() && loomExtension.getPlatform().get() == ModPlatform.FABRIC)
                for (Task classes : project.getTasksByName("classes", false))
                    classes.doLast("cakeEntrypoints", this::entrypoints);

            if (cakeExtension.getEnableMixins().get()) {
                for (Task classes : project.getTasksByName("classes", false)) {
                    classes.doLast("cakeMixins", this::mixins);
                    classes.doLast("cakeInterfaceInjections", this::interfaceInjections);
                }
            }
        }
    }

    private void entrypoints(Task task) {
        for (SourceSet sourceSet : task.getProject().getExtensions().getByType(JavaPluginExtension.class).getSourceSets())
            for (File resourcesDir : sourceSet.getResources().getSrcDirs()) {
                File jsonFile = new File(resourcesDir, "fabric.mod.json");
                if (!jsonFile.exists())
                    continue;

                for (File generatedSourcesDir : sourceSet.getOutput().getGeneratedSourcesDirs()) {
                    File entrypointsFile = new File(generatedSourcesDir, "cake/entrypoints.txt");
                    if (!entrypointsFile.exists())
                        continue;

                    final Map<String, Set<String>> entrypoints = new HashMap<>();

                    try {
                        JsonObject modJson;
                        try (FileReader fileReader = new FileReader(jsonFile)) {
                            modJson = JsonParser.parseReader(fileReader).getAsJsonObject();
                        }

                        JsonObject jEntrypoints = modJson.getAsJsonObject("entrypoints");
                        if (jEntrypoints == null)
                            jEntrypoints = new JsonObject();

                        for (Map.Entry<String, JsonElement> entry : jEntrypoints.entrySet()) {
                            Set<String> ep = entrypoints.computeIfAbsent(entry.getKey(), s -> new LinkedHashSet<>());
                            for (JsonElement element : entry.getValue().getAsJsonArray())
                                ep.add(element.getAsString());
                        }

                        Files.lines(entrypointsFile.toPath(), StandardCharsets.UTF_8)
                                .forEachOrdered(line -> {
                                    if (!line.isEmpty()) {
                                        int i = line.indexOf(' ');
                                        entrypoints.computeIfAbsent(line.substring(i + 1), s -> new LinkedHashSet<>()).add(line.substring(0, i));
                                    }
                                });

                        for (Map.Entry<String, Set<String>> entry : entrypoints.entrySet()) {
                            JsonArray ep = new JsonArray();

                            for (String s : entry.getValue())
                                ep.add(s);

                            jEntrypoints.add(entry.getKey(), ep);
                        }

                        try (FileReader fileReader = new FileReader(jsonFile = new File(sourceSet.getOutput().getResourcesDir(), "fabric.mod.json"))) {
                            modJson = JsonParser.parseReader(fileReader).getAsJsonObject();
                        }

                        if (jEntrypoints.size() == 0)
                            modJson.remove("entrypoints");
                        else
                            modJson.add("entrypoints", jEntrypoints);

                        Gson gson = new Gson();
                        try (FileWriter fileWriter = new FileWriter(jsonFile); JsonWriter writer = gson.newJsonWriter(fileWriter)) {
                            writer.setIndent("    ");
                            gson.toJson(modJson, writer);
                        }
                    } catch (IOException e) {
                        task.getProject().getLogger().error("Errored while inserting entrypoints.", e);
                    }
                }
            }
    }

    private void mixins(Task task) {
        LoomGradleExtension loomExtension = LoomGradleExtension.get(task.getProject());
        for (SourceSet sourceSet : task.getProject().getExtensions().getByType(JavaPluginExtension.class).getSourceSets())
            for (File resourcesDir : sourceSet.getResources().getSrcDirs()) {
                File jsonFile = new File(resourcesDir, "fabric.mod.json");
                //File forgeTomlFile = new File(resourcesDir, "META-INF/mods.toml");
                File forgeManifestFile = new File(resourcesDir, "META-INF/MANIFEST.MF");
                File neoForgeTomlFile = new File(resourcesDir, "META-INF/neoforge.mods.toml");
                if (!jsonFile.exists())
                    continue;
//                if (!forgeTomlFile.exists())
//                    continue;
                if (!neoForgeTomlFile.exists())
                    continue;

                for (File generatedSourcesDir : sourceSet.getOutput().getGeneratedSourcesDirs()) {
                    File mixinsFile = new File(generatedSourcesDir, "cake/mixins.txt");
                    if (!mixinsFile.exists())
                        continue;

                    try {
                        final Map<String, MixinEnvironment.Env> mixins = new HashMap<>();

                        Files.lines(mixinsFile.toPath(), StandardCharsets.UTF_8)
                                .forEachOrdered(line -> {
                                    if (!line.isEmpty()) {
                                        int i = line.indexOf(' ');
                                        mixins.put(line.substring(0, i), MixinEnvironment.Env.valueOf(line.substring(i + 1).toUpperCase(Locale.ENGLISH)));
                                    }
                                });

                        if (loomExtension.getPlatform().get() == ModPlatform.FABRIC) {
                            JsonObject json;
                            try (FileReader fileReader = new FileReader(jsonFile)) {
                                json = JsonParser.parseReader(fileReader).getAsJsonObject();
                            }

                            MixinEnvironment.Env modEnvironment = MixinEnvironment.Env.MIXINS;
                            JsonElement jEnvironment = json.get("environment");
                            if (jEnvironment != null)
                                switch (jEnvironment.getAsString()) {
                                    case "client":
                                        modEnvironment = MixinEnvironment.Env.CLIENT; break;
                                    case "server":
                                        modEnvironment = MixinEnvironment.Env.SERVER; break;
                                }

                            JsonArray jMixinConfigs = json.getAsJsonArray("mixins");
                            if (jMixinConfigs == null || jMixinConfigs.isEmpty())
                                continue; //todo generate new mixin config

                            for (JsonElement jMixinConfig : jMixinConfigs) {
                                String configName;
                                MixinEnvironment.Env environment = modEnvironment;
                                if (jMixinConfig.isJsonObject()) {
                                    configName = jMixinConfig.getAsJsonObject().get("config").getAsString();

                                    if (environment == MixinEnvironment.Env.MIXINS) {
                                        jEnvironment = jMixinConfig.getAsJsonObject().get("environment");
                                        if (jEnvironment != null)
                                            switch (jEnvironment.getAsString()) {
                                                case "client":
                                                    environment = MixinEnvironment.Env.CLIENT;
                                                    break;
                                                case "server":
                                                    environment = MixinEnvironment.Env.SERVER;
                                                    break;
                                            }
                                    }
                                } else
                                    configName = jMixinConfig.getAsString();

                                try (FileReader fileReader = new FileReader(jsonFile = new File(sourceSet.getOutput().getResourcesDir(), configName))) {
                                    json = JsonParser.parseReader(fileReader).getAsJsonObject();
                                }

                                JsonElement jMixinRoot = json.get("package");
                                if (jMixinRoot != null) {
                                    JsonArray jMixins = new JsonArray(), jClient = new JsonArray(), jServer = new JsonArray();

                                    String mixinRoot = jMixinRoot.getAsString();

                                    for (Map.Entry<String, MixinEnvironment.Env> entry : mixins.entrySet())
                                        if (entry.getKey().startsWith(mixinRoot)) {
                                            String relMixin = entry.getKey().substring(mixinRoot.length() + 1);
                                            switch (environment == MixinEnvironment.Env.MIXINS ? entry.getValue() : environment) {
                                                case MIXINS: jMixins.add(relMixin); break;
                                                case CLIENT: jClient.add(relMixin); break;
                                                case SERVER: jServer.add(relMixin); break;
                                            }
                                        }

                                    json.add("mixins", jMixins.isEmpty() ? null : jMixins);
                                    json.add("client", jClient.isEmpty() ? null : jClient);
                                    json.add("server", jServer.isEmpty() ? null : jServer);

                                    Gson gson = new Gson();
                                    try (FileWriter fileWriter = new FileWriter(jsonFile); JsonWriter writer = gson.newJsonWriter(fileWriter)) {
                                        writer.setIndent("    ");
                                        gson.toJson(json, writer);
                                    }
                                }
                            }
                        } else if (loomExtension.isNeoForge()) {
                            task.getProject().getLogger().warn("Auto write mixin config is experimental on NeoForge!");

                            JsonObject json;
                            UnmodifiableCommentedConfig toml;
                            try (FileReader fileReader = new FileReader(neoForgeTomlFile)) {
                                toml = TomlFormat.instance().createParser().parse(fileReader);
                            }

                            MixinEnvironment.Env modEnvironment = MixinEnvironment.Env.MIXINS;

                            List<UnmodifiableCommentedConfig> tMixinConfigs = toml.get("mixins");
                            if (tMixinConfigs == null || tMixinConfigs.isEmpty())
                                continue; //todo generate new mixin config

                            for (UnmodifiableCommentedConfig tMixinConfig : tMixinConfigs) {
                                String configName;
                                MixinEnvironment.Env environment = modEnvironment;

                                configName = tMixinConfig.get("config");

                                try (FileReader fileReader = new FileReader(neoForgeTomlFile = new File(sourceSet.getOutput().getResourcesDir(), configName))) {
                                    toml = TomlFormat.instance().createParser().parse(fileReader);
                                    json = JsonParser.parseReader(fileReader).getAsJsonObject();
                                }

                                JsonElement jMixinRoot = json.get("package");
                                if (jMixinRoot != null) {
                                    JsonArray jMixins = new JsonArray(), jClient = new JsonArray(), jServer = new JsonArray();

                                    String mixinRoot = jMixinRoot.getAsString();

                                    for (Map.Entry<String, MixinEnvironment.Env> entry : mixins.entrySet())
                                        if (entry.getKey().startsWith(mixinRoot)) {
                                            String relMixin = entry.getKey().substring(mixinRoot.length() + 1);
                                            switch (environment == MixinEnvironment.Env.MIXINS ? entry.getValue() : environment) {
                                                case MIXINS: jMixins.add(relMixin); break;
                                                case CLIENT: jClient.add(relMixin); break;
                                                case SERVER: jServer.add(relMixin); break;
                                            }
                                        }

                                    json.add("mixins", jMixins.isEmpty() ? null : jMixins);
                                    json.add("client", jClient.isEmpty() ? null : jClient);
                                    json.add("server", jServer.isEmpty() ? null : jServer);

                                    Gson gson = new Gson();
                                    ConfigWriter configWriter = TomlFormat.instance().createWriter();
                                    try (FileWriter fileWriter = new FileWriter(neoForgeTomlFile); JsonWriter writer = gson.newJsonWriter(fileWriter)) {
                                        writer.setIndent("    ");
                                        configWriter.writeToString(toml);
                                        gson.toJson(json, writer);
                                    }
                                }
                            }
                        } else if (loomExtension.isForge()) {
                            task.getProject().getLogger().error("Not support this feature on Minecraft Forge!");
                        }

                    } catch (Exception e) {
                        task.getProject().getLogger().error("Errored while inserting mixins.", e);
                    }
                }
            }
    }

    private void interfaceInjections(Task task) {
        LoomGradleExtension loomExtension = LoomGradleExtension.get(task.getProject());
        final ClassNameMapping mapping;
        try {
            mapping = new ClassNameMapping(task.getProject());
        } catch (IOException e) {
            task.getProject().getLogger().error("Errored while reading mappings.", e);
            return;
        }
        for (SourceSet sourceSet : task.getProject().getExtensions().getByType(JavaPluginExtension.class).getSourceSets())
            for (File resourcesDir : sourceSet.getResources().getSrcDirs()) {
                File jsonFile = new File(sourceSet.getOutput().getResourcesDir(), "fabric.mod.json");
                File commonJsonFile = new File(sourceSet.getOutput().getResourcesDir(), "architectury.common.json");
//                if (!commonJsonFile.exists())
//                    continue;
                if (!jsonFile.exists())
                    continue;

                for (File generatedSourcesDir : sourceSet.getOutput().getGeneratedSourcesDirs()) {
                    File interfaceInjectionsFile = new File(generatedSourcesDir, "cake/interfaceinjections.txt");
                    if (!interfaceInjectionsFile.exists())
                        continue;

                    final Map<String, Set<String>> interfaceInjections = new HashMap<>();

                    try {
                        if ((loomExtension.getPlatform().get() == ModPlatform.FABRIC) && !commonJsonFile.exists()) {
                            JsonObject modJson;
                            try (FileReader fileReader = new FileReader(jsonFile)) {
                                modJson = JsonParser.parseReader(fileReader).getAsJsonObject();
                            }

                            JsonObject jCustom = modJson.getAsJsonObject("custom");
                            if (jCustom == null)
                                modJson.add("custom", jCustom = new JsonObject());

                            JsonObject jInterfaceInjections = jCustom.getAsJsonObject("loom:injected_interfaces");
                            if (jInterfaceInjections == null)
                                jCustom.add("loom:injected_interfaces", jInterfaceInjections = new JsonObject());

                            for (Map.Entry<String, JsonElement> entry : jInterfaceInjections.entrySet()) {
                                Set<String> ep = interfaceInjections.computeIfAbsent(entry.getKey(), s -> new LinkedHashSet<>());
                                for (JsonElement element : entry.getValue().getAsJsonArray())
                                    ep.add(element.getAsString());
                            }

                            Files.lines(interfaceInjectionsFile.toPath(), StandardCharsets.UTF_8)
                                    .forEachOrdered(line -> {
                                        if (!line.isEmpty()) {
                                            int i = line.indexOf(' ');
                                            interfaceInjections.computeIfAbsent(mapping.remap(line.substring(i + 1)), s -> new LinkedHashSet<>()).add(line.substring(0, i));
                                        }
                                    });

                            for (Map.Entry<String, Set<String>> entry : interfaceInjections.entrySet()) {
                                JsonArray ep = new JsonArray();

                                for (String s : entry.getValue())
                                    ep.add(s);

                                jInterfaceInjections.add(entry.getKey(), ep);
                            }

                            Gson gson = new Gson();
                            try (FileWriter fileWriter = new FileWriter(jsonFile); JsonWriter writer = gson.newJsonWriter(fileWriter)) {
                                writer.setIndent("    ");
                                gson.toJson(modJson, writer);
                            }
                        } else if (!jsonFile.exists() && commonJsonFile.exists()) {
                            JsonObject commonJson;
                            try (FileReader fileReader = new FileReader(commonJsonFile)) {
                                commonJson = JsonParser.parseReader(fileReader).getAsJsonObject();
                            }

//                            JsonObject jCustom = commonJson.getAsJsonObject("custom");
//                            if (jCustom == null)
//                                commonJson.add("custom", jCustom = new JsonObject());

                            JsonObject jInterfaceInjections = commonJson.getAsJsonObject("injected_interfaces");
                            if (jInterfaceInjections == null)
                                commonJson.add("injected_interfaces", jInterfaceInjections = new JsonObject());

                            for (Map.Entry<String, JsonElement> entry : jInterfaceInjections.entrySet()) {
                                Set<String> ep = interfaceInjections.computeIfAbsent(entry.getKey(), s -> new LinkedHashSet<>());
                                for (JsonElement element : entry.getValue().getAsJsonArray())
                                    ep.add(element.getAsString());
                            }

                            Files.lines(interfaceInjectionsFile.toPath(), StandardCharsets.UTF_8)
                                    .forEachOrdered(line -> {
                                        if (!line.isEmpty()) {
                                            int i = line.indexOf(' ');
                                            interfaceInjections.computeIfAbsent(mapping.remap(line.substring(i + 1)), s -> new LinkedHashSet<>()).add(line.substring(0, i));
                                        }
                                    });

                            for (Map.Entry<String, Set<String>> entry : interfaceInjections.entrySet()) {
                                JsonArray ep = new JsonArray();

                                for (String s : entry.getValue())
                                    ep.add(s);

                                jInterfaceInjections.add(entry.getKey(), ep);
                            }

                            Gson gson = new Gson();
                            try (FileWriter fileWriter = new FileWriter(jsonFile); JsonWriter writer = gson.newJsonWriter(fileWriter)) {
                                writer.setIndent("    ");
                                gson.toJson(commonJson, writer);
                            }
                        }
                    } catch (IOException e) {
                        task.getProject().getLogger().error("Errored while inserting interface injections.", e);
                    }
                }
            }
    }
}
