/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.shcm.shsupercm.fabric.fletchingtable;

import com.google.gson.*;
import com.google.gson.stream.JsonWriter;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.Task;
import org.gradle.api.artifacts.Configuration;
import org.gradle.api.artifacts.dsl.DependencyHandler;
import org.gradle.api.file.FileCollection;
import org.gradle.api.plugins.JavaPlugin;
import org.gradle.api.plugins.JavaPluginExtension;
import org.gradle.api.provider.Property;
import org.gradle.api.tasks.SourceSet;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class FTGradlePlugin implements Plugin<Project> {
    private FletchingTableExtension fletchingTableExtension;

    @Override
    public void apply(Project project) {
        fletchingTableExtension = project.getExtensions().create("fletchingTable", FletchingTableExtension.class);

        project.afterEvaluate(this::afterEvaluate);

        project.getDependencies().getExtensions().create("includedJars", IncludedJarsExtension.class, project, fletchingTableExtension);
    }

    private void afterEvaluate(Project project) {
        FileCollection thisJar = project.files(getClass().getProtectionDomain().getCodeSource().getLocation());
        project.getDependencies().add(JavaPlugin.COMPILE_ONLY_CONFIGURATION_NAME, thisJar);

        System.out.println("ap: " + fletchingTableExtension.getEnableAnnotationProcessor().get());
        if (fletchingTableExtension.getEnableAnnotationProcessor().get()) {
            project.getDependencies().add(JavaPlugin.ANNOTATION_PROCESSOR_CONFIGURATION_NAME, thisJar);

            System.out.println("entrypoints: " + fletchingTableExtension.getEnableEntrypoints().get());
            if (fletchingTableExtension.getEnableEntrypoints().get())
                for (Task classes : project.getTasksByName("classes", false))
                    classes.doLast("entrypoints", this::entrypoints);
        }
    }

    private void entrypoints(Task task) {
        for (SourceSet sourceSet : task.getProject().getExtensions().getByType(JavaPluginExtension.class).getSourceSets())
            for (File resourcesDir : sourceSet.getResources().getSrcDirs()) {
                File jsonFile = new File(resourcesDir, "fabric.mod.json");
                if (!jsonFile.exists())
                    continue;

                for (File generatedSourcesDir : sourceSet.getOutput().getGeneratedSourcesDirs()) {
                    File entrypointsFile = new File(generatedSourcesDir, "fletchingtable/entrypoints.txt");
                    if (!entrypointsFile.exists())
                        continue;

                    final Map<String, Set<String>> entrypoints = new HashMap<>();

                    try {
                        JsonObject modJson = JsonParser.parseReader(new FileReader(jsonFile)).getAsJsonObject();

                        JsonObject jEntrypoints = modJson.getAsJsonObject("entrypoints");
                        if (jEntrypoints == null)
                            jEntrypoints = new JsonObject();

                        for (Map.Entry<String, JsonElement> entry : jEntrypoints.entrySet()) {
                            Set<String> ep = entrypoints.computeIfAbsent(entry.getKey(), s -> new LinkedHashSet<>());
                            for (JsonElement element : entry.getValue().getAsJsonArray())
                                ep.add(element.getAsString());
                        }

                        Files.lines(entrypointsFile.toPath(), StandardCharsets.UTF_8)
                                .forEachOrdered(line -> {
                                    if (!line.isEmpty()) {
                                        int i = line.indexOf(' ');
                                        entrypoints.computeIfAbsent(line.substring(i + 1), s -> new LinkedHashSet<>()).add(line.substring(0, i));
                                    }
                                });

                        for (Map.Entry<String, Set<String>> entry : entrypoints.entrySet()) {
                            JsonArray ep = new JsonArray();

                            for (String s : entry.getValue())
                                ep.add(s);

                            jEntrypoints.add(entry.getKey(), ep);
                        }

                        modJson = JsonParser.parseReader(new FileReader(jsonFile = new File(sourceSet.getOutput().getResourcesDir(), "fabric.mod.json"))).getAsJsonObject();

                        if (jEntrypoints.size() == 0)
                            modJson.remove("entrypoints");
                        else
                            modJson.add("entrypoints", jEntrypoints);

                        Gson gson = new Gson();
                        try (JsonWriter writer = gson.newJsonWriter(new FileWriter(jsonFile))) {
                            writer.setIndent("    ");
                            gson.toJson(modJson, writer);
                        }
                    } catch (IOException e) {
                        task.getProject().getLogger().debug("Errored while inserting entrypoints.", e);
                    }
                }
            }
    }

    public static abstract class IncludedJarsExtension {
        private final FletchingTableExtension fletchingTableExtension;
        private final File includedJarsCache;
        private final DependencyHandler dependencies;
        private final Configuration configuration;

        public IncludedJarsExtension(Project project, FletchingTableExtension fletchingTableExtension) {
            this.fletchingTableExtension = fletchingTableExtension;
            includedJarsCache = new File(project.getProjectDir(), ".gradle/fletchingtable/includedJarsCache");

            project.getRepositories().flatDir(repository -> {
                repository.dirs(includedJarsCache);
                repository.content(content ->
                        content.includeGroup("includedJars")
                );
            });

            this.dependencies = project.getDependencies();
            this.configuration = project.getConfigurations().create("includedJarsInternalConfiguration");
            this.configuration.setTransitive(false);
        }

        public void from(String dependencyString) {
            this.dependencies.add("includedJarsInternalConfiguration", dependencyString);
        }

        public void extractAll() {
            if (includedJarsCache.exists()) {
                for (File file : Objects.requireNonNull(includedJarsCache.listFiles()))
                    if (file.isFile())
                        file.delete();
            } else
                includedJarsCache.mkdirs();

            System.out.println("includedJars: " + fletchingTableExtension.getEnableIncludedJars().get());
            if (fletchingTableExtension.getEnableIncludedJars().get())
                for (File parentJarFile : this.configuration.resolve())
                    try {
                        try (ZipFile parentJarZip = new ZipFile(parentJarFile)) {
                            ZipEntry modJsonEntry = parentJarZip.getEntry("fabric.mod.json");
                            if (modJsonEntry != null) {
                                JsonObject modJson = JsonParser.parseReader(new InputStreamReader(parentJarZip.getInputStream(modJsonEntry), StandardCharsets.UTF_8)).getAsJsonObject();
                                JsonArray jars = modJson.getAsJsonArray("jars");
                                if (jars != null)
                                    for (JsonElement jar : jars) {
                                        String jarPath = jar.getAsJsonObject().get("file").getAsString();
                                        Files.copy(parentJarZip.getInputStream(parentJarZip.getEntry(jarPath)), includedJarsCache.toPath().resolve(jarPath.substring(jarPath.lastIndexOf('/') + 1)), StandardCopyOption.REPLACE_EXISTING);
                                    }
                            }
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
        }
    }

    public static abstract class FletchingTableExtension {
        public abstract Property<Boolean> getEnableEntrypoints();
        public abstract Property<Boolean> getEnableIncludedJars();

        public abstract Property<Boolean> getEnableAnnotationProcessor();

        public FletchingTableExtension() {
            getEnableEntrypoints().convention(true);
            getEnableIncludedJars().convention(true);

            getEnableAnnotationProcessor().convention(true);
        }
    }
}
